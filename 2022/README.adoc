= Advent 2022

I'm going it again in Reason, although I'll probably try my hand at coastML as well

I definitely can rewrite most of these to be more _functional_, carrying less state around & avoiding `Stream.iter`, but
also I'm relatively comfortable with the style...

== Day one

. part one: simple accumulation loop
. part two:
.. modify it to output the accumulations
.. `onep2.exe | grep -E '^accum' | sort`
.. `expr top1 + top2 + top3`

== Day Two

. part one: simple `play` lambda that plays hands of RPS
. part two: new lambda to rewrite input and then `play` the hand based on the strategic advice

== Day Three

. part one: slice strings in half, find the matching value in both containers
. part two: group elves together, and do a few folds over sorts to reduce the groups nicely

== Day Four

. part one: just `compare` a bunch, but make sure you get fully overlapped edge cases (I didn't think of `(0, 0)` at first)
. part two: literally just a giant chain of `&&`, `||`, and `<=` to check if any of the values were in range of one another

== Day Five

. part one: manually turn the puzzle input into a language, then parse the language
. part two: add a new micro-executor that just handles the new crane spec

Honestly, today was silly; sleep dep definitely got the best of me when doing things. I tripped myself up with `List.rev` at 
some point as well. 

== Day Six

. part one: use an alist to store characters we've seen, and if there's a member, we've seen, slide the window over by one
. part two: added an optional `start_message` parameter, and change the sliding window to 14 if `true`
.. I had figued this was coming and coded part one to support variable-sized windows to begin with

== Day Seven

. part one: build a hashtable and add sizes to the whole path
. part two: subtract two numbers

== Day Eight

. part one: manually iterated over all trees and checked visibility
. part two: took the code from part one and made it count rather than return a boolean

Honestly, this should have been done with a visibility matrix: I should have computed the weights ahead of time so look ups
would just check the neighbors' values, but the way I ended up doing it was easy enough...

== Day Nine

. part one: `dune exec bin/nine/nine.exe data/nine/actual | grep 'current' | awk '{print $6}' | sort | uniq | wc -l`
.. basically move around as needed
.. got part one
. part two: update a snaking list behind the head...

== Day Ten

. part one: instead of trying to time things, I just compiled into micro instructions that took 1 cycle each
.. part two: literally just compare the states from part one to the screen value at that cycle and draw it

== Day Eleven

. part one: build out a monkey evaluator 
.. got part one
. part two: eh, not going to figure out why this is off...

