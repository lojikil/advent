= 2023

I started in C this year, mostly because I actually did this on my work laptop and was too lazy to setup Reason again..

== Day One:

- part 1: test values in an array for digits, sum them
-- this actually started out way more complex, but then I simplified the logic and it was straight forward.
- part 2: brute force scanning for number words over the set
-- if we have a digit, stop
-- if we have a word, stop
-- else move to the next position

== Day Two:

I ended up being too lazy to manage strings in C and just went with python

- part 1: split strings, constrain
- part 2: append a list, run `reduce(max, color_list, 0)` for each color, multiply and add to the `power`

== Day Three:

- part 1: every year I tell myself that next year I will have an adjacency matrix figured out before advent of code, but not this year...
-- make an adjacency matrix, and fill it int
- part 2: note whenever we see a gear, and then group all the gears together. if we have 2 part numbers by a gear, multiply them, and sum all of those

== Day Four:

- part 1: count the cards, intersect the sets, and count the wins
- part 2: just add those wins to a work queue and re run them, it should be fine...
-- it was not fine
- part 3 (aka actual part 2 fix): there's a relationship between cards' scores, use that
-- `for idx in range(0, wins):`
--- `data[idx + cardno + 1] += data[cardno]`
-- the answer is `sum(list(data.values()))`

== Day Five:

- part 1: parse out, run lots of calculations
- part 2: expand out the seeds' ranges
- part 3: cry
- part 4: write a specializer that takes parts of the Python and generates C
-- actually solve the problem, but still by brute force 

== Day Six:

- part 1: parse out, dual loops, done
- part 2: glom the original races together, run the same code

This was a very small stretch, so I wonder if tomorrow will be BRUTAL in comparison

== Day Seven:

- part 1: ugh, I have to read all the rules carefully before playing
- part 2: ugh, I shouldn't try to write decision mapping code at 0200...
